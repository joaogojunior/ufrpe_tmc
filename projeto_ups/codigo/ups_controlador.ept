(*
    until => executa o estado em que estÃ¡ e transiciona para outro estado
    unless => transiciona para outro estado e executa o novo estado
*)

(*type pc_states = OFF | R1 | R3 | R4
node computador(sw_atx, c_atx, rup, rup_nc, rdown, rdown_nc :bool) returns (atuador, r1, r3, r4: bool;)
var a, d, u, o: bool;
let
   a = (*sw_atx or *)c_atx;
   d = rdown (*or rdown_nc*);
   u = rup (*or rup_nc*);
   o = a or d;
    automaton
    state Rlevel4 do
      r1 = false;
      r3 = false;
      r4 = true;
      atuador = true;
    unless a then Off
      | d then Rlevel3
    state Off do
      r1 = false;
      r3 = false;
      r4 = false;
      atuador = false;
    unless a then Rlevel4
    state Rlevel3 do
      r1 = false;
      r3 = true;
      r4 = false;
      atuador = true;
    unless u then Rlevel4
      | a then Off
      | d then Rlevel1
    state Rlevel1 do
      r1 = true;
      r3 = false;
      r4 = false;
      atuador = true;
    unless o then Off
      | u then Rlevel4
    end
tel
 *)

node computador(c_atx, off_atx, t :bool) returns (atuador:bool; estado: int;)
let
    automaton
    state Rlevel4 do
      estado = 2;
      atuador = true;
    unless c_atx then Off
    state Off do
      estado = 0;
      atuador = false;
    unless c_atx then Boot
    state Boot do
      estado = 1;
      atuador = true;
    unless t then Rlevel4
      | off_atx then Off
    end
tel

type bat_states =  BERR | B100 | B75 | B50 | B25
node bateria(cp, l1, l2, v:bool) returns (estado_bat:bat_states)
var a, b, c, d, e: bool;
let
   a = not cp & l1 & l2 & v;
   b = cp & l1 & l2 & v;
   c = not cp & not l1 & l2 & v;
   d = not cp & not l1 & not l2 & v;
   e = not a & not b & not c & not d;
    automaton
    state Erro do
      estado_bat = BERR;
    unless b then Carregado
      | a then Limiar1
      | c then Limiar2
      | d then Descarregado
    state Carregado do
      estado_bat = B100;
    unless a then Limiar1
      | e then Erro
    state Limiar1 do
      estado_bat = B75;
    unless b then Carregado
      | c then Limiar2
      | e then Erro
    state Limiar2 do
      estado_bat = B50;
    unless a then Limiar1
       | d then Descarregado
       | e then Erro
    state Descarregado do
      estado_bat = B25;
    unless c then Limiar2
       | e then Erro
    end
tel

node atuador_sw(ca:bool) returns (estado:bool)
let
    automaton
    state Des do
      estado = false;
    unless ca then Lig
    state Lig do
      estado = true;
    unless ca then Des
    end
tel

node periodo_dia(t:bool) returns (isday: bool)
let
    automaton
    state Dia do
      isday = true;
    unless t then Noite
    state Noite do
      isday = false;
    unless t then Dia
    end
tel

(*type modem_states = OFF | SLEEP | BOOT | TEST | ON*)
node modem_adsl(c, t, o :bool) returns (desligado, atuador: bool; estado:int)
let
    automaton
    state Off do
      estado = 0;
      desligado = true;
      atuador = false;
    unless c then Wait
    state Wait do
      estado = 2;
      desligado = false;
      atuador = true;
    unless t then Teste
       | c then Off
    state Teste do
       estado = 3;
       desligado = false;
       atuador = true;
     unless o then Online
       | not o then Sleep
       | c then Off
     state Online do
       estado = 4;
       desligado = false;
       atuador = true;
     unless t then Teste
       | c then Off
     state Sleep do
       estado = 1;
       desligado = false;
       atuador = false
     unless t then Wait
       | c then Off
    end
tel

node contrato(cb,l1b,l2b,vb,td, tm, om: bool)
 returns ( erro, relogio, pb, pm, ps, pabx, modem_atuador, serv_atuador: bool;  serv_estado: int; bat12v: bat_states)
    contract
 (*var relogio : bool;*)

let
(* politicas *)
tel
     enforce (pb & pm & ps)
     with (cp, cm, ca, co, ts:bool)
let
(* planta *)
    pabx = inlined atuador_sw(cp);
    modem_atuador = inlined atuador_sw(cm); 
(*    (modem_desligado, modem_atuador, modem_estado) = inlined modem_adsl(cm, tm, om); *)
    (serv_atuador, serv_estado) = inlined computador(ca,co,ts );

    relogio = inlined periodo_dia(td);
    bat12v = inlined bateria(cb, l1b, l2b, vb);

     switch bat12v
     | BERR do
          erro = true;
          pb = true;
          pm = true;
          ps = true;
     | B25 do
        switch relogio
          | true do (* dia *)
          erro = false;
          pb = not pabx;
          pm = not modem_atuador(* true*);
          ps = not serv_atuador;
          | false do (* noite *)
          erro = false;
          pb = not pabx;
          pm = not modem_atuador(* true*);
          ps = not serv_atuador;
        end
     | B50 do
        switch relogio
          | true do  (* dia *)
          erro = false;
          pb = pabx;
          pm = modem_atuador (*modem_estado > 0*);
          ps =  serv_estado > 0;
          | false do (* noite *)
          erro = false;
          pb = not pabx;
          pm = modem_atuador (*modem_estado > 0*);
          ps = not serv_atuador;
        end
     | B75 do
        switch relogio
          | true do (* dia *)
          erro = false;
          pb = pabx;
          pm = modem_atuador(* modem_estado > 0*);
          ps =  serv_estado > 0;
          | false do (* false *)
          erro = false;
          pb = not pabx;
          pm = modem_atuador (*modem_estado > 0*);
          ps = not serv_atuador;
        end
     | B100 do
       switch relogio
          | true do (* dia *)
          erro = false;
          pb = pabx;
          pm = modem_atuador (* modem_estado > 0*);
          ps =  serv_estado > 0;
          | false do (* noite *)
          erro = false;
          pb = pabx;
          pm = modem_atuador (* modem_estado > 0*);
          ps =  serv_estado > 0;
      end
  end
tel
